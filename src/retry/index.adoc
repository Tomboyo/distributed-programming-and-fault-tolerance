= Retry

A _Retry_ is a fault tolerance mechanism to help clients make successful requests despite interference from transient faults.

Retries help clients carry out requests against remote services even when short-lived, "transient" faults might otherwise prevent them from doing so <<amazon>>. These faults, like "the momentary loss of network connectivity to components and services, the temporary unavailability of a service, or timeouts that occur when a service is busy," frequently go away on their own <<azure-patterns-retry>>. If clients re-attempt requests that fail due to these faults, they are therefore likely to eventually succeed <<azure-patterns-retry>>. As a consequence, retry mechanisms improve a client's odds of successfully communicating with a service at the cost of issuing additional requests, which comes with a number of special considerations, outlined below.

== Considerations

* *Load*: Because retry mechanisms send more traffic to services in response to faults, they can place additional strain on already struggling services and hamper recovery <<amazon>><<azure-patterns-retry>>. This is mitigated several ways: by introducing a delay between retry attempts, which evenly distributes load against services <<amazon>><<azure-patterns-retry>>; by limiting the maximum number of retry attempts, thereby shedding load when requests chronically fail <<azure>>; and by protecting APIs with <<Rate Limiter,rate-limiters>> and <<Circuit Breaker,circuit-breakers>> that shed load further when services become chronically unhealthy <<amazon>>. Typically, the delay between retry attempts increases with successive attempts; this is known as _back-off_ <<azure>>, which is discussed further in <<Back-off, (TODO)>>.

* *Thundering Herd*: Distributed clients may unintentionally synchronize their retry requests into a https://en.wikipedia.org/wiki/Thundering_herd_problem[thundering herd], wherein many clients issue their retry requests at the same time instead of distributed over an interval. These traffic spikes cause service degradation and additional faults <<amazon>><<google>>. This is mitigated by adding a random component to the delay between requests, known as _jitter_, which spreads otherwise simultaneous requests back out <<amazon>>. Jitter is discussed further in <<Jitter, (TODO)>>.

* *Idempotence*: It may not be safe to retry failed requests against an API that causes link:https://en.wikipedia.org/wiki/Side_effect_(computer_science)[side effects], such as database state changes. A service might successfully create side effects even when a request fails overall; a subsequent attempt could trigger those effects again <<amazon>><<azure-patterns-retry>>. If repeated side effects are not desirable, design APIs that are link:https://en.wikipedia.org/wiki/Idempotence[idempotent] instead, and only issue retries to idempotent APIs <<amazon>><<azure-patterns-retry>>.
+
.Example
****
Suppose a client issues a bank API request to increment the value of an account by $100. The service successfully increments the value of the account, but the request fails overall due to an unrelated error (e.g. a network error). The client inappropriately retries the request, and as a result, increments the account by $200 cumulatively, not $100 as intended. Because the bank API is not idempotent, it is not safe to retry failed requests against it.
****

* *Distributed Systems*: When multiple services within a request path each use retry, a request to a service early in the path can multiply into a substantial number of requests that place additional strain on the service near the end <<amazon>><<azure-patterns-retry>>. For example, if the first service makes 3 retries to the second, which makes 3 retires to the third, the result may be as many as 9 requests to the third service. Limit retry logic to only one point in the stack to avoid the issue <<amazon>>, or only introduce retry when the consequences of failure are well-understood <<azure-patterns-retry>>.

* *When to Retry*: Because a Retry only helps a system recover from transient faults, retries must have selective triggers. Retries should generally not trigger in response to client errors (e.g. HTTP 4xx-series responses) since those are unlikely to ever succeed, but generally should trigger in response to server errors (e.g. HTTP 5xx-series responses) because those may succeed on a subsequent attempt <<amazon>>. This is contextual, however; <<azure-patterns-retry,Microsoft>> notes that internal server errors (e.g. HTTP 500 responses) may be caused by business-logic defects, and these types of failures would not succeed on retried attempts. Retry trigger logic is futher complicated in an eventually-consistent environment where otherwise chronic errors may resolve as state propagates throughout a system <<amazon>>.
